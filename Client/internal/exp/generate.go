package exp

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"GYscan/internal/utils"

	"github.com/fatih/color"
)

type POCGenerator struct {
	Templates map[string]*template.Template
}

type POCOptions struct {
	Target     string
	Port       int
	SSL        bool
	OutputFile string
	Language   string
}

func NewPOCGenerator() *POCGenerator {
	return &POCGenerator{
		Templates: make(map[string]*template.Template),
	}
}

func (g *POCGenerator) GeneratePOC(exploit Exploit, options POCOptions) ([]byte, error) {
	exploitPath, err := GetExploitFilePath(exploit)
	if err != nil {
		utils.LogWarning("无法找到漏洞利用文件: %v", err)
		return nil, err
	}

	content, err := os.ReadFile(exploitPath)
	if err != nil {
		utils.LogWarning("读取漏洞利用文件失败: %v", err)
		return nil, err
	}

	baseContent := g.addHeader(content, exploit, options)

	if options.OutputFile != "" {
		filename := g.determineFilename(exploit, options)
		outputPath := filepath.Join(options.OutputFile, filename)

		dir := filepath.Dir(outputPath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			utils.LogWarning("创建输出目录失败: %v", err)
			return nil, err
		}

		if err := os.WriteFile(outputPath, baseContent, 0644); err != nil {
			utils.LogWarning("写入文件失败: %v", err)
			return nil, err
		}

		utils.LogSuccess("PoC已保存到: %s", outputPath)
	}

	return baseContent, nil
}

func (g *POCGenerator) addHeader(content []byte, exploit Exploit, options POCOptions) []byte {
	var header strings.Builder

	header.WriteString(fmt.Sprintf("# Exploit Database - GYscan Generated PoC\n"))
	header.WriteString(fmt.Sprintf("# EDB-ID: %d\n", exploit.ID))
	header.WriteString(fmt.Sprintf("# Description: %s\n", exploit.Description))
	header.WriteString(fmt.Sprintf("# Platform: %s\n", exploit.Platform))
	header.WriteString(fmt.Sprintf("# Type: %s\n", exploit.Type))
	header.WriteString(fmt.Sprintf("# Author: %s\n", exploit.Author))
	header.WriteString(fmt.Sprintf("# Date Published: %s\n", exploit.DatePublished))

	if exploit.Codes != "" {
		header.WriteString(fmt.Sprintf("# CVE: %s\n", exploit.Codes))
	}

	header.WriteString(fmt.Sprintf("#\n"))
	header.WriteString(fmt.Sprintf("# Generated by GYscan\n"))
	header.WriteString(fmt.Sprintf("# Generated at: %s\n", utils.GetCurrentTime()))
	header.WriteString(fmt.Sprintf("# Target: %s\n", options.Target))
	if options.Port > 0 {
		header.WriteString(fmt.Sprintf("# Port: %d\n", options.Port))
	}
	header.WriteString(fmt.Sprintf("#\n"))
	header.WriteString(fmt.Sprintf("# WARNING: This is PoC code for educational purposes only.\n"))
	header.WriteString(fmt.Sprintf("# Use only on systems you have permission to test.\n"))
	header.WriteString(fmt.Sprintf("# =========================================\n\n"))

	header.WriteString(string(content))
	return []byte(header.String())
}

func (g *POCGenerator) determineFilename(exploit Exploit, options POCOptions) string {
	var ext string

	switch {
	case strings.Contains(exploit.File, ".py"):
		ext = ".py"
	case strings.Contains(exploit.File, ".rb"):
		ext = ".rb"
	case strings.Contains(exploit.File, ".php"):
		ext = ".php"
	case strings.Contains(exploit.File, ".pl"):
		ext = ".pl"
	case strings.Contains(exploit.File, ".c"):
		ext = ".c"
	case strings.Contains(exploit.File, ".js"):
		ext = ".js"
	case strings.Contains(exploit.File, ".sh"):
		ext = ".sh"
	default:
		ext = ".txt"
	}

	safeDesc := strings.ReplaceAll(exploit.Description, " ", "_")
	safeDesc = strings.ReplaceAll(safeDesc, "/", "_")
	safeDesc = strings.ReplaceAll(safeDesc, "\\", "_")
	safeDesc = strings.ReplaceAll(safeDesc, ":", "_")
	safeDesc = strings.ReplaceAll(safeDesc, "*", "_")
	safeDesc = strings.ReplaceAll(safeDesc, "?", "_")

	if len(safeDesc) > 50 {
		safeDesc = safeDesc[:50]
	}

	return fmt.Sprintf("poc_%d_%s%s", exploit.ID, safeDesc, ext)
}

func GenerateSimplePOC(exploit Exploit, target string, port int) string {
	var poc strings.Builder

	poc.WriteString(fmt.Sprintf("#!/usr/bin/env python3\n"))
	poc.WriteString(fmt.Sprintf("# -*- coding: utf-8 -*-\n"))
	poc.WriteString(fmt.Sprintf("#\n"))
	poc.WriteString(fmt.Sprintf("# Exploit for: %s\n", exploit.Description))
	poc.WriteString(fmt.Sprintf("# EDB-ID: %d\n", exploit.ID))
	poc.WriteString(fmt.Sprintf("# Platform: %s\n", exploit.Platform))
	poc.WriteString(fmt.Sprintf("#\n"))
	poc.WriteString(fmt.Sprintf("\n"))
	poc.WriteString(fmt.Sprintf("import requests\n"))
	poc.WriteString(fmt.Sprintf("import sys\n"))
	poc.WriteString(fmt.Sprintf("import argparse\n"))
	poc.WriteString(fmt.Sprintf("\n"))
	poc.WriteString(fmt.Sprintf("def check_vulnerability(target, port=80, ssl=False):\n"))
	poc.WriteString(fmt.Sprintf("    url = f\"{'https' if ssl else 'http'}://{target}:{port}\"\n"))
	poc.WriteString(fmt.Sprintf("    print(f\"[*] Checking vulnerability at {url}\")\n"))
	poc.WriteString(fmt.Sprintf("    \n"))
	poc.WriteString(fmt.Sprintf("    try:\n"))
	poc.WriteString(fmt.Sprintf("        response = requests.get(url, timeout=10)\n"))
	poc.WriteString(fmt.Sprintf("        print(f\"[+] Target is reachable\")\n"))
	poc.WriteString(fmt.Sprintf("        return True\n"))
	poc.WriteString(fmt.Sprintf("    except Exception as e:\n"))
	poc.WriteString(fmt.Sprintf("        print(f\"[-] Error: {{e}}\")\n"))
	poc.WriteString(fmt.Sprintf("        return False\n"))
	poc.WriteString(fmt.Sprintf("\n"))
	poc.WriteString(fmt.Sprintf("def exploit(target, port=80, ssl=False):\n"))
	poc.WriteString(fmt.Sprintf("    if check_vulnerability(target, port, ssl):\n"))
	poc.WriteString(fmt.Sprintf("        print(f\"[+] Exploit may be applicable\")\n"))
	poc.WriteString(fmt.Sprintf("    else:\n"))
	poc.WriteString(fmt.Sprintf("        print(f\"[-] Target does not appear vulnerable\")\n"))
	poc.WriteString(fmt.Sprintf("\n"))
	poc.WriteString(fmt.Sprintf("if __name__ == \"__main__\":\n"))
	poc.WriteString(fmt.Sprintf("    parser = argparse.ArgumentParser(description='Exploit for %s')\n", exploit.Description[:50]))
	poc.WriteString(fmt.Sprintf("    parser.add_argument('--target', required=True, help='Target IP or hostname')\n"))
	poc.WriteString(fmt.Sprintf("    parser.add_argument('--port', type=int, default=80, help='Target port')\n"))
	poc.WriteString(fmt.Sprintf("    parser.add_argument('--ssl', action='store_true', help='Use SSL')\n"))
	poc.WriteString(fmt.Sprintf("    args = parser.parse_args()\n"))
	poc.WriteString(fmt.Sprintf("    \n"))
	poc.WriteString(fmt.Sprintf("    exploit(args.target, args.port, args.ssl)\n"))

	return poc.String()
}

func PrintPOC(exploit Exploit) {
	path, err := GetExploitFilePath(exploit)
	if err != nil {
		utils.LogWarning("无法找到漏洞利用文件: %v", err)
		return
	}

	content, err := os.ReadFile(path)
	if err != nil {
		utils.LogWarning("读取漏洞利用文件失败: %v", err)
		return
	}

	cyan := color.New(color.FgCyan)
	cyan.Printf("\n[EDB-ID: %d] %s\n", exploit.ID, exploit.Description)
	utils.LogInfo("平台: %s | 类型: %s | 文件: %s", exploit.Platform, exploit.Type, exploit.File)
	if exploit.Codes != "" {
		utils.LogInfo("CVE: %s", exploit.Codes)
	}
	fmt.Println(strings.Repeat("=", 80))
	fmt.Println()
	fmt.Println(string(content))
	fmt.Println(strings.Repeat("=", 80))
}

func CopyPOC(exploit Exploit, outputDir string) error {
	path, err := GetExploitFilePath(exploit)
	if err != nil {
		return fmt.Errorf("无法找到漏洞利用文件: %v", err)
	}

	content, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("读取漏洞利用文件失败: %v", err)
	}

	filename := filepath.Base(path)
	outputPath := filepath.Join(outputDir, filename)

	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %v", err)
	}

	if err := os.WriteFile(outputPath, content, 0644); err != nil {
		return fmt.Errorf("写入文件失败: %v", err)
	}

	utils.LogSuccess("PoC已复制到: %s", outputPath)
	return nil
}

func GenerateNmapScript(exploit Exploit) string {
	var script strings.Builder

	script.WriteString(fmt.Sprintf("local http = require \"http\"\n"))
	script.WriteString(fmt.Sprintf("local shortport = require \"shortport\"\n"))
	script.WriteString(fmt.Sprintf("local stdnse = require \"stdnse\"\n"))
	script.WriteString(fmt.Sprintf("local string = require \"string\"\n"))
	script.WriteString(fmt.Sprintf("\n"))
	script.WriteString(fmt.Sprintf("description = [[\n"))
	script.WriteString(fmt.Sprintf("Check for %s\n", exploit.Description))
	script.WriteString(fmt.Sprintf("EDB-ID: %d\n", exploit.ID))
	script.WriteString(fmt.Sprintf("]])\n"))
	script.WriteString(fmt.Sprintf("\n"))
	script.WriteString(fmt.Sprintf("author = \"GYscan\"\n"))
	script.WriteString(fmt.Sprintf("license = \"Same as Nmap--See https://nmap.org/book/man-legal.html\"\n"))
	script.WriteString(fmt.Sprintf("\n"))
	script.WriteString(fmt.Sprintf("-- @usage nmap --script=%s <target>\n", "vuln-"+strings.ReplaceAll(exploit.Description, " ", "-")))
	script.WriteString(fmt.Sprintf("-- @output\n"))
	script.WriteString(fmt.Sprintf("-- PORT   STATE SERVICE REASON\n"))
	script.WriteString(fmt.Sprintf("-- 80/tcp open  http    syn-ack\n"))
	script.WriteString(fmt.Sprintf("-- |_vuln-test: VULNERABLE:\n"))
	script.WriteString(fmt.Sprintf("\n"))
	script.WriteString(fmt.Sprintf("portrule = shortport.http\n"))
	script.WriteString(fmt.Sprintf("\n"))
	script.WriteString(fmt.Sprintf("action = function(host, port)\n"))
	script.WriteString(fmt.Sprintf("    local response = http.get(host, port, \"/\")\n"))
	script.WriteString(fmt.Sprintf("    if response.status == 200 then\n"))
	script.WriteString(fmt.Sprintf("        return \"VULNERABLE: %s\"\n", exploit.Description))
	script.WriteString(fmt.Sprintf("    end\n"))
	script.WriteString(fmt.Sprintf("    return nil\n"))
	script.WriteString(fmt.Sprintf("end\n"))

	return script.String()
}
